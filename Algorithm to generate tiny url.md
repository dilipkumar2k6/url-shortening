# Encode string to generate Tiny URL
Following sets of allowed characters
- a to z (26)
- A to Z (26)
- 0 to 9 (10)
- Include `/` and `+` (2)
Total characters = 26 + 26 + 10 + 2 = 64 
Note: If exclude `/` and `+` the total characters will be 62. It is better to exclude as these are 
Total decided characters = 62

If tiny url is `7` characters long then it can generate = 62 ** 7 tiny url 
= 3,521,614,606,208 ~ 3.5 trillion
- If server needs to generate 1000 tiny url per second then it will take ~111 years to exhaust it.

- If server needs to generate 1000,000 tiny url per second then it will take ~1.3 months to exhaust it.
Note: We are assuming that server needs to generate 1000 tiny url per second
Note: 2**42 ~= 4.3 trillion i.e. we need total 42 bits to represent it.
# Technique to generate tiny url
- Generate random tiny URL and check DB
- Pick first 42 bits for MD5/SHA256
- Counter 
    - Single host
    - All host
    - Range based
## Generate random tiny url and check DB
- Generate a 42 bits long random number
- Use these 42 bits to generate tiny url of size 7 characters
- App server will do upsert on database based on tiny url with original url and expect db to return back original document
- If original url is not matching then retry new random tiny url
## Pick first 42 bits for MD5/SHA256
Note: Since MD5 is weak therefore recommended to go with SHA256
Note: Md5 generate 128 bits hash and Sha256 generates 256 bits

- Generate Sha256 hash of given original url
- Take the first 42 bits of hashed url
- Use these 42 bits to generate tiny url of size 7 characters
- There is probability of collision 
- To handle collision, need to apply database check logic as discussed in previous approach

## Counter based approach
### Single host
- There will be a single counter host which job is increment counter on request and return back new counter
- All worker nodes request new counter from counter node and convert that counter to 7 chars long tiny url
Note: Chances of collisions are lot

### All host
- Every host internally try to manage this counter
- Suppose we have 64 worker host
- We need 6 bits to generate 64 numbers
- Assign unique 6 bits number to each 64 hosts
- Generate timestamp and take 32 bits out of it
- Then add 4 bits of either random or incremental sequence number
- i.e total will be 6 + 32 + 4 = 42

What is probability of collision?
- Pretty high with 1000 request per seconds
- I.e. every worker host will be handing 1000/64 ~= 16 per seconds
- I.e. in a seconds, the last 4 bits needs to be generated unique for 16 requests
- These 4 bits will generate max of 2**4 = 16 therefore it is pretty good chances to have collision for those 16 requests
- If you design to use incremented sequence for those 4 bits then once it reach 16 then it will fail
- Also, if adding/removing host then first `6` bits assigned will not be stable
### Range based approach
- Based on maximum number of combinations can be generated by using 7 characters
- Range based approach uses as many such combinations as possible
- To start with, just focus on 1st billion
- Divide 1st billion combinations into 1000 ranges and maintain in the zookeeper
    - 1 to 1 million
    - 1 million to 2 million
    - 2 million to 3 million
    - x million to x +1 million
    - 999 million to 1000 million
- Worker nodes come to zookeeper and ask for unused range
- Worker will create counter as per this range
- Once worker node exhaust counter as per range then it will request new range from zookeeper
- Once worker node die then system will that range; once worker node come back then it will request for range and zookeeper will assign new range
- Once zookeepr will exhaust all 1 billion range then will create new set of range and update zookeeper

Is there any problem to generate url based on counter?
- Yes
- Increasing counter can be predicted by hacker
- To handle it, we can add another 10 bits to allocate for random number
- This will make total as 52 bits which will generate 9 to 10 chars long tiny bit url

## What is benefit of random approach vs sha256 approach?
- If two users are requesting tiny url for same url then random approach will generate two different tiny url, which will lead to store two separate document in database which means higher data storage.
- With sha256 approach, two different users requesting for same url will generate same tiny url therefore storage on db will be less.

# How to convert 42 bits into 7 characters long tiny url?
- Take an example 101000100111000111000111001100100100000001
- Convert to decimal i.e 2790774327553
- Convert to base62 i.e n8Fofa5
Reference: https://jalu.ch/coding/base_converter.php

# How to convert counter into 7 chars long tiny url?
- With base 62 and 7 chars long, it can generate 62**7 ~= 3.5 trillion numbers
- Make sure to generate counter between 1 and 3.5 trillion
- Take that counter and convert to 62 base number which will always be max 7 chars long




